#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Generate Boost.Describe declarations for all struct/class definitions
found in a target header file (and only that header).

Output format:
  - A single header (UTF-8) that opens the corresponding namespaces
    and calls BOOST_DESCRIBE_STRUCT(Type, (), (field1, field2, ...)).

Notes:
  - We filter cursors by location.file == target header to avoid pulling
    system decls (e.g., CRT stuff).
  - Fields are collected via CursorKind.FIELD_DECL.
  - This script writes the file directly with UTF-8 (no stdout redirection).
"""

import os
import sys
import argparse
from clang.cindex import Index, Config, CursorKind

def parse_args():
    ap = argparse.ArgumentParser(description="Generate Boost.Describe macros for all structs in a header.")
    ap.add_argument("--libclang", required=True, help="Path to libclang shared library (e.g., libclang.dll)")
    ap.add_argument("--out", required=True, help="Output header path")
    ap.add_argument("header", help="Target header (e.g., model.hpp)")
    # Optional: pass extra include dirs, std, etc., if needed later
    ap.add_argument("--std", default="c++20", help="C++ standard (default: c++20)")
    ap.add_argument("-I", dest="includes", action="append", default=[], help="Additional include directories")
    return ap.parse_args()

def set_libclang(path):
    path = os.path.abspath(path)
    if not os.path.exists(path):
        raise FileNotFoundError(f"libclang not found: {path}")
    Config.set_library_file(path)

def is_from_target_header(cursor, target_abs):
    """
    Check if cursor location originates from the given header path.
    """
    try:
        loc = cursor.location
        if not loc or not loc.file:
            return False
        cur_path = os.path.abspath(loc.file.name)
        return os.path.normcase(cur_path) == os.path.normcase(target_abs)
    except Exception:
        return False

def get_qualified_name(cursor):
    """
    Build a (namespace_parts, type_name) pair.
    Example: namespace hello { struct User { ... }; }
    returns (["hello"], "User")
    """
    ns_parts = []
    cur = cursor.semantic_parent
    while cur is not None and cur.kind != CursorKind.TRANSLATION_UNIT:
        if cur.kind == CursorKind.NAMESPACE and cur.spelling:
            ns_parts.append(cur.spelling)
        cur = cur.semantic_parent
    ns_parts.reverse()
    return ns_parts, cursor.spelling

def collect_structs(tu, target_abs):
    """
    Traverse AST and collect user-defined struct/class declarations
    from the target header only. Returns list of:
      { "ns": ["hello"], "name": "User", "fields": ["name","age",...]}
    """
    result = []

    def visit(c):
        # Recurse
        for ch in c.get_children():
            visit(ch)

        # Interested in struct/class only
        if c.kind not in (CursorKind.STRUCT_DECL, CursorKind.CLASS_DECL):
            return
        if not c.is_definition():
            return
        if not c.spelling:  # anonymous
            return
        if not is_from_target_header(c, target_abs):
            return

        # Collect fields (public by default for struct; libclang does not always expose access reliably)
        fields = []
        for mem in c.get_children():
            if mem.kind == CursorKind.FIELD_DECL and mem.spelling:
                # Keep only fields from the same header (guard against injected/system members)
                if is_from_target_header(mem, target_abs):
                    fields.append(mem.spelling)

        ns, name = get_qualified_name(c)
        result.append({"ns": ns, "name": name, "fields": fields})

    visit(tu.cursor)

    # Deduplicate by (ns tuple, name)
    seen = set()
    uniq = []
    for item in result:
        key = (tuple(item["ns"]), item["name"])
        if key in seen:
            continue
        seen.add(key)
        uniq.append(item)
    return uniq

def generate_header(structs):
    """
    Render a single header with namespace blocks and BOOST_DESCRIBE_STRUCT lines.
    """
    lines = []
    lines.append("// This file is generated by gen_all_structs.py - DO NOT EDIT")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <boost/describe.hpp>")
    lines.append("")

    # Group by namespace list
    from collections import defaultdict
    groups = defaultdict(list)
    for s in structs:
        groups[tuple(s["ns"])].append(s)

    def open_namespaces(ns_parts):
        for ns in ns_parts:
            lines.append(f"namespace {ns} {{")
    def close_namespaces(ns_parts):
        for ns in reversed(ns_parts):
            lines.append(f"}} // namespace {ns}")

    # Sort for deterministic output
    for ns_parts in sorted(groups.keys(), key=lambda t: (len(t), t)):
        items = sorted(groups[ns_parts], key=lambda x: x["name"])
        if ns_parts:
            open_namespaces(ns_parts)
            lines.append("")

        for it in items:
            fields = it["fields"]
            field_list = ", ".join(fields) if fields else ""
            # Describe only if we have at least one field; Boost.Describe allows empty too, but usually not useful.
            lines.append(f"BOOST_DESCRIBE_STRUCT({it['name']}, (), ({field_list}))")

        if ns_parts:
            lines.append("")
            close_namespaces(ns_parts)
            lines.append("")

    # Final newline
    lines.append("")
    return "\n".join(lines)

def main():
    args = parse_args()
    set_libclang(args.libclang)

    header_abs = os.path.abspath(args.header)
    if not os.path.exists(header_abs):
        print(f"[error] header not found: {header_abs}", file=sys.stderr)
        sys.exit(1)

    index = Index.create()
    clang_args = [
        "-x", "c++",
        f"-std={args.std}",
        "-D__CODEGEN__=1",
        f"-I{os.path.dirname(header_abs)}",
    ]
    for inc in args.includes:
        clang_args.append(f"-I{inc}")

    # Parse (note: we parse the header directly; warnings like '#pragma once in main file' are harmless)
    tu = index.parse(header_abs, args=clang_args)

    targets = collect_structs(tu, header_abs)
    text = generate_header(targets)

    out_path = os.path.abspath(args.out)
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, "w", encoding="utf-8", newline="\n") as f:
        f.write(text)

if __name__ == "__main__":
    main()
